{"version":3,"sources":["Cell.js","Field.js","App.js","index.js"],"names":["Cell","row","col","color","onClick","style","top","left","backgroundColor","onClickCallback","useCallback","className","filter","join","Field","props","cells","flatMap","map","key","onCellClick","range","count","result","i","push","getRandomColor","random","Math","copyMatrix","matrix","cell","getAdjacentCellsOfSameColor","rowsCount","length","colsCount","getAdjacentCells","doesAnyCellHaveSameColorNeighbour","some","_","moveColumnsDown","cellsCopy","forEach","index","column","colIndex","getColumn","colors","mutateColumnColors","reducer","state","action","type","queue","pop","adjacentCellsOfSameColor","unshift","removeCellsOfSameColor","data","movedCells","isGameOver","initState","width","height","App","useReducer","dispatch","gameOverLabel","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.79d92d74.chunk.js","sourcesContent":["import React, {useCallback} from 'react';\nimport PropTypes from 'prop-types';\n\nimport './Cell.css';\n\nconst CELL_SIZE = 50;\n\nexport default function Cell({row, col, color, onClick}) {\n  const style = {\n    top: row * CELL_SIZE,\n    left: col * CELL_SIZE,\n    backgroundColor: color,\n  };\n\n  const onClickCallback = useCallback(() => onClick({row, col, color}), [\n    onClick,\n    row,\n    col,\n    color,\n  ]);\n\n  const className = ['Cell', color === null ? 'Cell_empty' : null]\n    .filter(className => className !== null)\n    .join(' ');\n\n  return <div className={className} style={style} onClick={onClickCallback} />;\n}\n\nCell.propTypes = {\n  row: PropTypes.number,\n  col: PropTypes.number,\n  color: PropTypes.string,\n  onClick: PropTypes.func,\n};\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport Cell from './Cell';\n\nimport './Field.css';\n\nexport default function Field(props) {\n  const cells = props.cells.flatMap(row =>\n    row.map(({row, col, color}) => (\n      <Cell\n        key={row + '-' + col}\n        row={row}\n        col={col}\n        color={color}\n        onClick={props.onCellClick}\n      />\n    )),\n  );\n  return <div className=\"Field\">{cells}</div>;\n}\n\nField.propTypes = {\n  cells: PropTypes.array,\n  onCellClick: PropTypes.func,\n};\n","import React, {useReducer, useCallback} from 'react';\n\nimport Field from './Field';\n\nimport './App.css';\n\nconst range = count => {\n  const result = [];\n  for (let i = 0; i < count; i++) {\n    result.push(null);\n  }\n  return result;\n};\n\nconst getRandomColor = () => {\n  const random = Math.random();\n  if (random < 0.25) {\n    return 'red';\n  } else if (random < 0.5) {\n    return 'green';\n  } else if (random < 0.75) {\n    return 'blue';\n  } else {\n    return 'yellow';\n  }\n};\n\nconst copyMatrix = matrix => matrix.map(row => row.map(cell => ({...cell})));\n\nconst getColumn = (cells, colIndex) => {\n  const rowsCount = cells.length;\n  return range(rowsCount).map((_, row) => cells[row][colIndex]);\n};\n\nconst mutateColumnColors = (cells, colIndex, colors) => {\n  const rowsCount = cells.length;\n  range(rowsCount).forEach((_, row) => {\n    cells[row][colIndex].color = colors[row];\n  });\n  return cells;\n};\n\nconst getAdjacentCells = (cells, {row, col}) => {\n  const rowsCount = cells.length;\n  const colsCount = cells[0].length;\n  return [\n    {row: row - 1, col},\n    {row, col: col + 1},\n    {row: row + 1, col},\n    {row, col: col - 1},\n  ]\n    .filter(\n      ({row, col}) =>\n        0 <= row && row < rowsCount && 0 <= col && col < colsCount,\n    )\n    .map(({row, col}) => cells[row][col]);\n};\n\nconst getAdjacentCellsOfSameColor = (cells, {row, col}, color) => {\n  return getAdjacentCells(cells, {row, col}).filter(\n    cell => cell.color === color,\n  );\n};\n\nconst doesAnyCellHaveSameColorNeighbour = cells => {\n  const rowsCount = cells.length;\n  const colsCount = cells[0].length;\n\n  return range(rowsCount).some((_, row) =>\n    range(colsCount).some((_, col) => {\n      const cell = cells[row][col];\n\n      if (cell.color === null) {\n        return false;\n      }\n\n      return (\n        getAdjacentCellsOfSameColor(cells, {row, col}, cell.color).length > 0\n      );\n    }),\n  );\n};\n\n/**\n * This function implements a BFS, using queue here helps to avoid limitation of call stack size (in case of\n * recursive solution)\n */\nconst removeCellsOfSameColor = (cells, {col, row, color}) => {\n  if (color === null) {\n    return cells;\n  }\n\n  if (getAdjacentCellsOfSameColor(cells, {col, row}, color).length === 0) {\n    return cells;\n  }\n\n  const cellsCopy = copyMatrix(cells);\n  const queue = [cellsCopy[row][col]];\n  cellsCopy[row][col].color = null;\n\n  while (queue.length > 0) {\n    const cell = queue.pop();\n    const adjacentCellsOfSameColor = getAdjacentCellsOfSameColor(\n      cellsCopy,\n      cell,\n      color,\n    );\n\n    adjacentCellsOfSameColor.forEach(({row, col}) => {\n      cellsCopy[row][col].color = null;\n    });\n\n    queue.unshift(...adjacentCellsOfSameColor);\n  }\n\n  return cellsCopy;\n};\n\n/**\n * One of other possible ways to solve this is to store a transposed matrix and move it to the left (inside of moving\n * it down). This will make `getColumn` and  `mutateColumnColors` functions redundant. It should be a more optimal\n * solution, but it comes with a trade-off of unusual/inconvinient matrix dimensions, so I decided to stick to\n * this approach.\n */\nconst moveColumnsDown = cells => {\n  const colsCount = cells[0].length;\n  let cellsCopy = copyMatrix(cells);\n\n  range(colsCount).forEach((_, index) => {\n    const column = getColumn(cellsCopy, index);\n\n    const colors = column\n      .map(cell => cell.color)\n      .filter(color => color !== null);\n\n    cellsCopy = mutateColumnColors(cellsCopy, index, [\n      ...range(column.length - colors.length),\n      ...colors,\n    ]);\n  });\n\n  return cellsCopy;\n};\n\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'CELL_CLICK': {\n      const cells = removeCellsOfSameColor(state.cells, action.data);\n      const movedCells = moveColumnsDown(cells);\n      return {\n        cells: movedCells,\n        isGameOver: !doesAnyCellHaveSameColorNeighbour(movedCells),\n      };\n    }\n\n    default:\n      return state;\n  }\n};\n\nconst initState = ({width, height}) => {\n  const cells = range(height).map((_, row) => {\n    return range(width).map((_, col) => ({\n      row,\n      col,\n      color: getRandomColor(),\n    }));\n  });\n  return {cells};\n};\n\nfunction App() {\n  const [state, dispatch] = useReducer(\n    reducer,\n    {width: 10, height: 10},\n    initState,\n  );\n\n  const onCellClick = useCallback(\n    data => dispatch({type: 'CELL_CLICK', data}),\n    [],\n  );\n\n  const gameOverLabel =\n    state.isGameOver ? (\n      <div className=\"App__game-over-label\">\n        <h2>Game over!</h2>\n        <p>Press ⌘-R or Ctrl-R to restart</p>\n      </div>\n    ) : null;\n\n  return (\n    <div>\n      <div className=\"App__field\">\n        <Field cells={state.cells} onCellClick={onCellClick} />\n      </div>\n      {gameOverLabel}\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}